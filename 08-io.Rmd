# (PART) Input/ Output {-}

# Introduction to I/O {#io}

So, you probs want to be able to talk to devices, but how? Read on, and learn.

Figure out:

* relationship between io and pio

## Basics

To communicate with the outside world, and receive communication back, we will need to learn how to create, and receive, signals and pulses. To deal with these correctly we will also need to cover how properly enforce timings in our programs. 

### Signals

The simplest example of a signal is turning a device on or off. This can be done by manipulating an appropriating bit from a ```0``` to a ```1```. If the address of the device is stored in ```OUT1``` we can affect it like this:

```
TURNON  LDA $%00000001
        STA OUT1
```

Assuming the power control bit is the 0 bit, this would turn the relay on. However, this would also change all other bits in the register. A simple change to the program will fix this:

```
TURNON  LDA OUT1
        ORA $%00000001
        STA OUT1
```

The inclusive OR (ORA) will change only bit 1 here, and leave the rest intact.

To generate a pulse we would need to change the bit, then at a later point change it back. However, to do this we have to be able to accurately track the length of this delay.

### Delays

Delays can be generated by either software or hardware. Lets begin with the software side. Software delays are accomplished by counting. This is done by loading a register with a value and decrementing till we hit zero. Knowing the speed of the 6502 instruction set we can then accurately make delays of certain lengths.

```
DELAY   LDY   #07
NEXT    DEY   
        BNE   NEXT
```

The above code loads the integer ```7``` into Y then loops until it is decremented to zero. Then, it will move on. Lets look at how long these instructions take:

* LDY: 2 cycles
* DEY: 2 cycles
* BNE: 3 cycles (2 if no branch occurs)
* If a page boundary is crossed, 1 extra cycle

The LDY instruction will occur once, and the loop happens 7 times, with one of the BNE instructions only costing 2 cycles. So, the delay is calculated by: 

$$
\begin{aligned}
& 2 + 5 \times 7 = 36  
\end{aligned}
$$

The delay can be increased by loading a larger value into Y (up to 255). Or, you could make use of NOP - this does nothing for 2 cycles. 

For even longer delays, we would need to use 2 counters. Here, when the first counter reached zero, the second would be decremented by 1 and the first counter would be filled again. When the second counter gets to zero, the program terminates. However, this will result in the microprocessor doing nothing for potentially seconds. This can be acceptable in some situations, by may be a waste if other tasks could be being performed. Because of this, long delays are not usually dealt with by software, but rather by hardware. In some situations, if we need to guarentee accurace in the delay, even short delays may be done by hardware.

Hardware delays are implemented by programmable interval timers. The timer's register is loaded with a value and this is automatically decremented over time. When it is finished it will send an interupt to the program (interupts will be explained soon!).

### Sensing Pulses 

The opposite problem to creating pulses of a accurate length is sensing them. However, this includes an added problem. The programmer has control over generating a pulse, but has no control over when one may be recieved. We therefore must be always ready to detect one. This is done by _polling_ and _interupts_.

Polling is when the program watches and test a value in a certain register. When we recieve a pulse, this value we are watching will change. 

```
POLL    LDA   #$01
AGAIN   BIT   INPUT
        BEQ   AGAIN
ON      ......
```

The above example monitors bit 0 until it takes the value of 1. When this happens the program will break out of the loop and continue. A small modification will allow us to poll for a zero rather than a one:

```
POLL    LDA   #$01
AGAIN   BIT   INPUT
        BNE   AGAIN
ON      ......
```

Counting the duration of a pulse is done in a similar way to the previous examples. A counter will be incremented as long as the pulse exists. This counter will then be used to find the duration. For example:

```
DURTN   LDX   #0
        LDA   #$01
AGAIN   BIT   INPUT
        BEQ   AGAIN ; break out when pulse is detected (1)
LONGER  INX
        BIT INPUT
        BNE LONGER ; break out when pulse goes away (0)
```

The code detects a pulse, as before, then enters a second loop. Here, it increments X and when the pulse ends the loop can be broken out off. However, if X were to increase above 255 it would overflow. To count above that we would need to modify the program.

## Bit Transfer

### Parallel Bit Transfer

### Serial Bit Transfer

## Conclusions