# Data Representation {#bin}

We need to look at the computer's internal and external representation of data - this is binary and ASCII. Its external representation (what we have as input or output) is decimal or hexadecimal.

## Internal Representations 

* A bit is a binary digit - a 0 or a 1

* 4 bits is a nibble, 8 is a byte

Microprocessors, like the 6502, store data internally as bytes. This data will need to be the program instructions and the data itself. The data will either be numeric or alphanumeric.

### Program Instructions

A program is essentially a list of instructions. These are stored as single or multiple bytes. The 6502 fetches bytes from memory. Therefore, a single byte instruction is faster than a multiple byte instruction. This is an important consideration when programming the 6502. The instructions the 6502 has will be discussed later.

### Numeric Data

To represent numeric data a numerous cases need to be taken care of. Firstly, we'll look at integers, which we'll represent with direct binary. Here, the right most bit represents 2^0^, the next one to the left is 2^1^, then 2^2^, and so on. The eights bits ($b$) of one byte will be represented as:

$$ b_{7}b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}b_{0} $$

The powers of 2 are:

$$ 2^7 = 128,\;2^6 = 64,\;2^5 = 32,\;2^4 = 16,\;2^3 = 8,\;2^2 = 4,\;2^1 = 2,\;2^0 = 1 $$

So, a binary number, like ```0010 0011``` is:

$$ 
\begin{aligned}
 &  \quad b_{5} + b_{1} + b_{0} \\
 &  = 2^{5} + 2^{1} + 2^{0} \\
 &  = 32 + 2 + 1 \\
 &  = 35 
\end{aligned}
$$

You can go the other way to, from decimal to binary. Lets try 35 again:

$$
\begin{aligned}
& 35 \div 2 = 17 r 1 \rightarrow 1 \\
& 17 \div 2 =\enspace8 r 1 \rightarrow 1 \\
&\enspace8 \div 2 =\enspace4 r 0 \rightarrow 0 \\
&\enspace4 \div 2 =\enspace2 r 0 \rightarrow 0 \\
&\enspace2 \div 2 =\enspace1 r 0 \rightarrow 0 \\
&\enspace1 \div 2 =\enspace0 r 1 \rightarrow 1 \\
&\enspace0 \div 2 =\enspace0 r 0 \rightarrow 0 \\
&\enspace0 \div 2 =\enspace0 r 0 \rightarrow 0 \\
\end{aligned}
$$

This method give us a result of ```0010 0011```, which is what we'd expect.

Addition works as it would "normally". Single bits follow these rules:

$$
\begin{aligned}
& 0 + 0 = \quad\;0 \\
& 1 + 0 = \quad\;1 \\
& 0 + 1 = \quad\;1 \\
& 1 + 1 = (1)0 \\
\end{aligned}
$$

The $(1)$ represents a carry. Note, $10$ is the binary equivilent of 2. $2 + 1$ is done like:

$$
\begin{aligned}
& \enspace\; 10 \\
& \underline{+01} \\
& \enspace\; 11 \\
\end{aligned}
$$

The bits can "carry", like in normal integer addition. $3 + 1$ is:

$$
\begin{aligned}
& \enspace\; 0011 \\
& \underline{+0001} \\
& \enspace\; 0100 \\
\end{aligned}
$$

Our binary numbers can add correctly, and we can represent our integers correctly. However, there are two problems:

* We can only go up to 255 (if we only use 8 bits)
* We can only represent positive numbers

To solve the latter issue, we will introduce signed binary.

#### Signed Binary {-}

The left most bit is used for the sign. 

1 is: ```0000 0001``` while -1 is: ```1000 0001```

Immediatelly, we have reduced the magnitude from 255 to 127, oops. We can represent negative numbers now however. Lets try addition, $7$ and $-5$:

$$
\begin{aligned}
& \enspace\; 0000 0111 \\
& \underline{+1000 0101} \\
& \enspace\; 1000 1100 \\
\end{aligned}
$$

This is a problem, ```1000 1100``` is $-12$, which is clearly wrong. The solution to this is _two's complement_. To get to this point we will first have to introduce _one's complement_.

#### One and Two's Complement {-}

In One's Complement the positive number stays the same, ie, 1 is still```0000 0001```.
However, to get the negative we "swap" all the bits - all 0's become 1's and all 1's become 0's. This means -1 is: ```1111 1110```. As with signed binary, all positive numbers start with 0 and all negatives start with 1.

Lets try adding $-4$ and $+6$:

$$
\begin{aligned}
& \enspace\; 1111 0011 \\
& \underline{+0000 0110} \\
& \enspace\; 0000 0001 \\
\end{aligned}
$$

We have got a result of $1$, instead of $2$. We will have to expand one's complement before we get correct addition.

Two's Complement:

You do One's Complement, then, for the negative number, add 1

3 is: ```0000 0011``` while -3 is ```1111 1101```

Everything Works! This is the representation of binary that will be used from now on. 

#### The Carry and the Overflow {-}

While adding/ subtracting numbers there are things to look for.

* If you add 128 (```1000 0000```) and 129 (```1000 0001```) is 257. The binary addition will result in ```(1) 0000 0001```. This extra, ninth bit, is the **Carry** bit. This needs to be recognised and handled inside the processor. 

* Adding 64 (```0100 0000```) and 65 (```0100 0001```) results in ```1000 0001```, which is -127, and wrong. This is because of an internal carry from bit 6 to bit 7. When this bit change, that results in a sign change, occurs, this is what is called the **Overflow** bit.

### Alphanumeric Data

Its ASCII, you get it.

## External Representations

Its hexadecimal, you get it.

Sometimes just like decimals as well, you also get it.

fuck BCD and octadecimal.
[@zaks]
